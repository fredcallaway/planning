// Generated by CoffeeScript 1.12.3

/*
jspsych-mouselab-mdp.coffee
Fred Callaway

https://github.com/fredcallaway/Mouselab-MDP
 */
var D, SCORE, TIME_LEFT, WATCH, mdp,
  slice = [].slice,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

mdp = void 0;

D = void 0;

WATCH = {};

SCORE = 0;

TIME_LEFT = void 0;

jsPsych.plugins['mouselab-mdp'] = (function() {
  var Arrow, Edge, KEYS, LOG_DEBUG, LOG_INFO, MouselabMDP, NULL, PRINT, RIGHT_MESSAGE, SIZE, State, TOP_ADJUST, TRIAL_INDEX, Text, angle, checkObj, dist, plugin, polarMove, redGreen, removePrivate, round;
  PRINT = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return console.log.apply(console, args);
  };
  NULL = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return null;
  };
  LOG_INFO = PRINT;
  LOG_DEBUG = NULL;
  SIZE = void 0;
  TRIAL_INDEX = 0;
  TOP_ADJUST = -16;
  fabric.Object.prototype.originX = fabric.Object.prototype.originY = 'center';
  fabric.Object.prototype.selectable = false;
  fabric.Object.prototype.hoverCursor = 'plain';
  removePrivate = function(obj) {
    return _.pick(obj, (function(v, k, o) {
      return !k.startsWith('_');
    }));
  };
  angle = function(x1, y1, x2, y2) {
    var ang, x, y;
    x = x2 - x1;
    y = y2 - y1;
    if (x === 0) {
      ang = y === 0 ? 0 : y > 0 ? Math.PI / 2 : Math.PI * 3 / 2;
    } else if (y === 0) {
      ang = x > 0 ? 0 : Math.PI;
    } else {
      ang = x < 0 ? Math.atan(y / x) + Math.PI : y < 0 ? Math.atan(y / x) + 2 * Math.PI : Math.atan(y / x);
    }
    return ang + Math.PI / 2;
  };
  polarMove = function(x, y, ang, dist) {
    x += dist * Math.sin(ang);
    y -= dist * Math.cos(ang);
    return [x, y];
  };
  dist = function(o1, o2) {
    return Math.pow(Math.pow(o1.left - o2.left, 2) + Math.pow(o1.top - o2.top, 2), 0.5);
  };
  redGreen = function(val) {
    if (val > 0) {
      return '#080';
    } else if (val < 0) {
      return '#b00';
    } else {
      return '#666';
    }
  };
  round = function(x) {
    return (Math.round(x * 100)) / 100;
  };
  checkObj = function(obj, keys) {
    var i, k, len;
    if (keys == null) {
      keys = Object.keys(obj);
    }
    for (i = 0, len = keys.length; i < len; i++) {
      k = keys[i];
      if (obj[k] === void 0) {
        console.log('Bad Object: ', obj);
        throw new Error(k + " is undefined");
      }
    }
    return obj;
  };
  KEYS = mapObject({
    up: 'uparrow',
    down: 'downarrow',
    right: 'rightarrow',
    left: 'leftarrow',
    simulate: 'space'
  }, jsPsych.pluginAPI.convertKeyCharacterToKeyCode);
  RIGHT_MESSAGE = '\xa0'.repeat(8) + 'Score: <span id=mouselab-score/>';
<<<<<<< HEAD
  // =============================== #
  // ========= MouselabMDP ========= #
  // =============================== #
  MouselabMDP = class MouselabMDP {
    constructor(config) {
      var blockName, centerMessage, leftMessage, lowerMessage, prompt, rightMessage, size, trial_id;
      this.startTimer = this.startTimer.bind(this);
      // ---------- Responding to user input ---------- #

      // Called when a valid action is initiated via a key press.
      this.handleKey = this.handleKey.bind(this);
      this.startSimulationMode = this.startSimulationMode.bind(this);
      this.endSimulationMode = this.endSimulationMode.bind(this);
      this.getOutcome = this.getOutcome.bind(this);
      this.getReward = this.getReward.bind(this);
      this.move = this.move.bind(this);
      this.clickState = this.clickState.bind(this);
      this.mouseoverState = this.mouseoverState.bind(this);
      this.mouseoutState = this.mouseoutState.bind(this);
      this.clickEdge = this.clickEdge.bind(this);
      this.mouseoverEdge = this.mouseoverEdge.bind(this);
      this.mouseoutEdge = this.mouseoutEdge.bind(this);
      this.getEdgeLabel = this.getEdgeLabel.bind(this);
      this.recordQuery = this.recordQuery.bind(this);
      // ---------- Updating state ---------- #

      // Called when the player arrives in a new state.
      this.arrive = this.arrive.bind(this);
      this.addScore = this.addScore.bind(this);
      this.resetScore = this.resetScore.bind(this);
      this.drawScore = this.drawScore.bind(this);
      this.spendEnergy = this.spendEnergy.bind(this);
      // $('#mouselab-').css 'color', redGreen SCORE

      // ---------- Starting the trial ---------- #
      this.run = this.run.bind(this);
      // Draw object on the canvas.
      this.draw = this.draw.bind(this);
      // Draws the player image.
      this.initPlayer = this.initPlayer.bind(this);
      // Constructs the visual display.
      this.buildMap = this.buildMap.bind(this);
      // ---------- ENDING THE TRIAL ---------- #

      // Creates a button allowing user to move to the next trial.
      this.endTrial = this.endTrial.bind(this);
      this.checkFinished = this.checkFinished.bind(this);
      // @transition=null  # function `(s0, a, s1, r) -> null` called after each transition
      
      // leftMessage="Round: #{TRIAL_INDEX}/#{N_TRIAL}"
      ({display: this.display, graph: this.graph, layout: this.layout, initial: this.initial, stateLabels: this.stateLabels = 'reward', stateDisplay: this.stateDisplay = 'never', stateClickCost: this.stateClickCost = 0, edgeLabels: this.edgeLabels = 'never', edgeDisplay: this.edgeDisplay = 'always', edgeClickCost: this.edgeClickCost = 0, stateRewards: this.stateRewards = null, clickDelay: this.clickDelay = 0, moveDelay: this.moveDelay = 500, clickEnergy: this.clickEnergy = 0, moveEnergy: this.moveEnergy = 0, allowSimulation: this.allowSimulation = false, revealRewards: this.revealRewards = true, training: this.training = false, special: this.special = '', timeLimit: this.timeLimit = null, energyLimit: this.energyLimit = null, keys: this.keys = KEYS, trialIndex: this.trialIndex = TRIAL_INDEX, playerImage: this.playerImage = 'static/images/plane.png', size = 80, trial_id = null, blockName = 'none', prompt = '&nbsp;', leftMessage = '&nbsp;', centerMessage = '&nbsp;', rightMessage = RIGHT_MESSAGE, lowerMessage = '&nbsp;'} = config); // html display element // defines transition and reward functions // defines position of states // initial state of player // object mapping from state names to labels // one of 'never', 'hover', 'click', 'always' // subtracted from score every time a state is clicked // object mapping from edge names (s0 + '__' + s1) to labels // one of 'never', 'hover', 'click', 'always' // subtracted from score every time an edge is clicked // mapping from actions to keycodes // number of trial (starts from 1) // determines the size of states, text, etc...
=======
  MouselabMDP = (function() {
    function MouselabMDP(config) {
      this.checkFinished = bind(this.checkFinished, this);
      this.endTrial = bind(this.endTrial, this);
      this.buildMap = bind(this.buildMap, this);
      this.initPlayer = bind(this.initPlayer, this);
      this.draw = bind(this.draw, this);
      this.run = bind(this.run, this);
      this.spendEnergy = bind(this.spendEnergy, this);
      this.drawScore = bind(this.drawScore, this);
      this.resetScore = bind(this.resetScore, this);
      this.addScore = bind(this.addScore, this);
      this.arrive = bind(this.arrive, this);
      this.recordQuery = bind(this.recordQuery, this);
      this.getEdgeLabel = bind(this.getEdgeLabel, this);
      this.mouseoutEdge = bind(this.mouseoutEdge, this);
      this.mouseoverEdge = bind(this.mouseoverEdge, this);
      this.clickEdge = bind(this.clickEdge, this);
      this.mouseoutState = bind(this.mouseoutState, this);
      this.mouseoverState = bind(this.mouseoverState, this);
      this.clickState = bind(this.clickState, this);
      this.move = bind(this.move, this);
      this.getReward = bind(this.getReward, this);
      this.getOutcome = bind(this.getOutcome, this);
      this.endSimulationMode = bind(this.endSimulationMode, this);
      this.startSimulationMode = bind(this.startSimulationMode, this);
      this.handleKey = bind(this.handleKey, this);
      this.startTimer = bind(this.startTimer, this);
      var blockName, centerMessage, leftMessage, lowerMessage, prompt, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref27, ref3, ref4, ref5, ref6, ref7, ref8, ref9, rightMessage, size, trial_id;
      this.display = config.display, this.graph = config.graph, this.layout = config.layout, this.initial = config.initial, this.stateLabels = (ref = config.stateLabels) != null ? ref : 'reward', this.stateDisplay = (ref1 = config.stateDisplay) != null ? ref1 : 'never', this.stateClickCost = (ref2 = config.stateClickCost) != null ? ref2 : 0, this.edgeLabels = (ref3 = config.edgeLabels) != null ? ref3 : 'never', this.edgeDisplay = (ref4 = config.edgeDisplay) != null ? ref4 : 'always', this.edgeClickCost = (ref5 = config.edgeClickCost) != null ? ref5 : 0, this.stateRewards = (ref6 = config.stateRewards) != null ? ref6 : null, this.clickDelay = (ref7 = config.clickDelay) != null ? ref7 : 0, this.moveDelay = (ref8 = config.moveDelay) != null ? ref8 : 500, this.clickEnergy = (ref9 = config.clickEnergy) != null ? ref9 : 0, this.moveEnergy = (ref10 = config.moveEnergy) != null ? ref10 : 0, this.allowSimulation = (ref11 = config.allowSimulation) != null ? ref11 : true, this.revealRewards = (ref12 = config.revealRewards) != null ? ref12 : true, this.training = (ref13 = config.training) != null ? ref13 : false, this.special = (ref14 = config.special) != null ? ref14 : '', this.timeLimit = (ref15 = config.timeLimit) != null ? ref15 : null, this.energyLimit = (ref16 = config.energyLimit) != null ? ref16 : null, this.keys = (ref17 = config.keys) != null ? ref17 : KEYS, this.trialIndex = (ref18 = config.trialIndex) != null ? ref18 : TRIAL_INDEX, this.playerImage = (ref19 = config.playerImage) != null ? ref19 : 'static/images/plane.png', size = (ref20 = config.size) != null ? ref20 : 80, trial_id = (ref21 = config.trial_id) != null ? ref21 : null, blockName = (ref22 = config.blockName) != null ? ref22 : 'none', prompt = (ref23 = config.prompt) != null ? ref23 : '&nbsp;', leftMessage = (ref24 = config.leftMessage) != null ? ref24 : '&nbsp;', centerMessage = (ref25 = config.centerMessage) != null ? ref25 : '&nbsp;', rightMessage = (ref26 = config.rightMessage) != null ? ref26 : RIGHT_MESSAGE, lowerMessage = (ref27 = config.lowerMessage) != null ? ref27 : '&nbsp;';
>>>>>>> 89c4631e18a3661fb2a497a47ba915d7318153b9
      LOG_INFO('NAME', this.name);
      SIZE = size;
      _.extend(this, config);
      checkObj(this);
      if (this.stateLabels === 'reward') {
        this.stateLabels = this.stateRewards;
      }
      this.stateLabels[0] = '';
      if (this.energyLimit) {
        leftMessage = 'Energy: <b><span id=mouselab-energy/></b>';
        if (this._block.energyLeft == null) {
          this._block.energyLeft = this.energyLimit;
        }
      } else {
        leftMessage = "Round " + (this._block.trialCount + 1) + "/" + this._block.timeline.length;
      }
      this.data = {
        trial_id: trial_id,
        block: blockName,
        trialIndex: this.trialIndex,
        score: 0,
        rewards: [],
        path: [],
        rt: [],
        actions: [],
        actionTimes: [],
        simulationMode: [],
        queries: {
          click: {
            state: {
              'target': [],
              'time': []
            },
            edge: {
              'target': [],
              'time': []
            }
          },
          mouseover: {
            state: {
              'target': [],
              'time': []
            },
            edge: {
              'target': [],
              'time': []
            }
          },
          mouseout: {
            state: {
              'target': [],
              'time': []
            },
            edge: {
              'target': [],
              'time': []
            }
          }
        }
      };
      if ($('#mouselab-msg-right').length) {
        this.leftMessage = $('#mouselab-msg-left');
        this.leftMessage.html(leftMessage);
        this.centerMessage = $('#mouselab-msg-center');
        this.centerMessage.html(centerMessage);
        this.rightMessage = $('#mouselab-msg-right');
        this.rightMessage.html(rightMessage);
        this.stage = $('#mouselab-stage');
        this.prompt = $('#mouselab-prompt');
        this.prompt.html(prompt);
        console.log('prompt', prompt);
      } else {
        this.display.empty();
        this.leftMessage = $('<div>', {
          id: 'mouselab-msg-left',
          "class": 'mouselab-header',
          html: leftMessage
        }).appendTo(this.display);
        this.centerMessage = $('<div>', {
          id: 'mouselab-msg-center',
          "class": 'mouselab-header',
          html: centerMessage
        }).appendTo(this.display);
        this.rightMessage = $('<div>', {
          id: 'mouselab-msg-right',
          "class": 'mouselab-header',
          html: rightMessage
        }).appendTo(this.display);
        this.prompt = $('<div>', {
          id: 'mouselab-prompt',
          "class": 'mouselab-prompt',
          html: prompt
        }).appendTo(this.display);
        this.stage = $('<div>', {
          id: 'mouselab-stage'
        }).appendTo(this.display);
        if (this.timeLimit) {
          TIME_LEFT = this.timeLimit;
        }
      }
      this.canvasElement = $('<canvas>', {
        id: 'mouselab-canvas'
      }).attr({
        width: 500,
        height: 500
      }).appendTo(this.stage);
      this.lowerMessage = $('<div>', {
        id: 'mouselab-msg-bottom',
        html: lowerMessage || '&nbsp'
      }).appendTo(this.stage);
      this.defaultLowerMessage = lowerMessage;
      mdp = this;
      LOG_INFO('new MouselabMDP', this);
      this.invKeys = _.invert(this.keys);
      this.resetScore();
      this.spendEnergy(0);
      this.freeze = false;
      this.lowerMessage.css('color', '#000');
    }

    MouselabMDP.prototype.startTimer = function() {
      var $timer, formatTime, start, tick;
      $timer = $('#mouselab-msg-left');
      start = getTime();
      this.timerID = null;
      formatTime = function(time) {
        var minutes, seconds;
        seconds = time % 60;
        minutes = Math.floor(time / 60);
        return (minutes ? (minutes > 9 ? minutes : '0' + minutes) : '00') + ':' + (seconds > 9 ? seconds : '0' + seconds);
      };
      tick = (function(_this) {
        return function() {
          if (TIME_LEFT < 0) {
            console.log('DONE');
            window.clearInterval(_this.timerID);
            _this.lowerMessage.html("<b>Time is up! Press any key to continue.</br>");
            return _this.endBlock();
          } else {
            $timer.html("Time: <b>" + (formatTime(TIME_LEFT)) + "</b>");
            return TIME_LEFT -= 1;
          }
        };
      })(this);
      tick();
      return this.timerID = window.setInterval(tick, 1000);
    };

    MouselabMDP.prototype.endBlock = function() {
      console.log('endBlock');
      this.blockOver = true;
      jsPsych.pluginAPI.cancelAllKeyboardResponses();
      return this.keyListener = jsPsych.pluginAPI.getKeyboardResponse({
        valid_responses: ['space'],
        rt_method: 'date',
        persist: false,
        allow_held_key: false,
        callback_function: (function(_this) {
          return function(info) {
            console.log('CLEAR');
            jsPsych.finishTrial(_this.data);
            _this.display.empty();
            return jsPsych.endCurrentTimeline();
          };
        })(this)
      });
    };

    MouselabMDP.prototype.handleKey = function(s0, a) {
      var _, ref, s1;
      LOG_INFO('handleKey', s0, a);
      if (a === 'simulate') {
        if (this.simulationMode) {
          return this.endSimulationMode();
        } else {
          return this.startSimulationMode();
        }
      } else {
        if (!this.simulationMode) {
          this.allowSimulation = false;
          if (this.defaultLowerMessage) {
            this.lowerMessage.html('<b>Move with the arrow keys.</b>');
            this.lowerMessage.css('color', '#000');
          }
        }
        this.data.actions.push(a);
        this.data.simulationMode.push(this.simulationMode);
        this.data.actionTimes.push(Date.now() - this.initTime);
        ref = this.graph[s0][a], _ = ref[0], s1 = ref[1];
        return this.move(s0, a, s1);
      }
    };

    MouselabMDP.prototype.startSimulationMode = function() {
      this.simulationMode = true;
      this.player.set('top', this.states[this.initial].top - 20).set('left', this.states[this.initial].left);
      this.player.set('opacity', 0.4);
      this.canvas.renderAll();
      this.arrive(this.initial);
      this.rightMessage.html('Ghost Score: <span id=mouselab-score/>');
      this.resetScore();
      this.drawScore(this.data.score);
      return this.lowerMessage.html("<b>👻 Ghost Mode 👻</b>\n<br>\nPress <code>space</code> to return to your corporeal form.");
    };

    MouselabMDP.prototype.endSimulationMode = function() {
      this.simulationMode = false;
      this.player.set('top', this.states[this.initial].top).set('left', this.states[this.initial].left);
      this.player.set('opacity', 1);
      this.canvas.renderAll();
      this.arrive(this.initial);
      this.centerMessage.html('');
      this.rightMessage.html(RIGHT_MESSAGE);
      this.resetScore();
      return this.lowerMessage.html(this.defaultLowerMessage);
    };

    MouselabMDP.prototype.getOutcome = function(s0, a) {
      var r, ref, s1;
      LOG_DEBUG("getOutcome " + s0 + ", " + a);
      ref = this.graph[s0][a], s1 = ref[0], r = ref[1];
      if (this.stateRewards != null) {
        console.log('YES');
        r = this.stateRewards[s1];
      }
      return [r, s1];
    };

    MouselabMDP.prototype.getReward = function(s0, a, s1) {
      if (this.stateRewards != null) {
        return this.stateRewards[s1];
      } else {
        return this.graph[s0][a];
      }
    };

    MouselabMDP.prototype.move = function(s0, a, s1) {
      var nClick, newTop, notEnoughClicks, r, s1g;
      this.moved = true;
      if (this.freeze) {
        LOG_INFO('freeze!');
        this.arrive(s0, 'repeat');
        return;
      }
      nClick = this.data.queries.click.state.target.length;
      notEnoughClicks = (this.special.startsWith('trainClick')) && nClick < 3;
      if (notEnoughClicks) {
        this.lowerMessage.html('<b>Inspect at least three nodes before moving!</b>');
        this.lowerMessage.css('color', '#FC4754');
        this.special = 'trainClickBlock';
        this.arrive(s0, 'repeat');
        return;
      }
      r = this.getReward(s0, a, s1);
      LOG_DEBUG("move " + s0 + ", " + s1 + ", " + r);
      s1g = this.states[s1];
      this.freeze = true;
      newTop = this.simulationMode ? s1g.top - 20 : s1g.top + TOP_ADJUST;
      return this.player.animate({
        left: s1g.left,
        top: newTop
      }, {
        duration: this.moveDelay,
        onChange: this.canvas.renderAll.bind(this.canvas),
        onComplete: (function(_this) {
          return function() {
            _this.data.rewards.push(r);
            _this.addScore(r);
            _this.spendEnergy(_this.moveEnergy);
            return _this.arrive(s1);
          };
        })(this)
      });
    };

    MouselabMDP.prototype.clickState = function(g, s) {
      var r;
      LOG_INFO("clickState " + s);
      if (this.moved) {
        this.lowerMessage.html("<b>You can't use the node inspector after moving!</b>");
        this.lowerMessage.css('color', '#FC4754');
        return;
      }
      if (this.complete || (("" + s) === ("" + this.initial)) || this.freeze) {
        return;
      }
      if (this.special === 'trainClickBlock' && this.data.queries.click.state.target.length === 2) {
        this.lowerMessage.html('<b>Nice job! You can click on more nodes or start moving.</b>');
        this.lowerMessage.css('color', '#000');
      }
      if (this.stateLabels && this.stateDisplay === 'click' && !g.label.text) {
        this.addScore(-this.stateClickCost);
        this.recordQuery('click', 'state', s);
        this.spendEnergy(this.clickEnergy);
        r = this.stateLabels[s];
        if (this.clickDelay) {
          this.freeze = true;
          g.setLabel('...');
          return delay(this.clickDelay, (function(_this) {
            return function() {
              _this.freeze = false;
              g.setLabel(r);
              return _this.canvas.renderAll();
            };
          })(this));
        } else {
          return g.setLabel(r);
        }
      }
    };

    MouselabMDP.prototype.mouseoverState = function(g, s) {
      if (this.stateLabels && this.stateDisplay === 'hover') {
        g.setLabel(this.stateLabels[s]);
        return this.recordQuery('mouseover', 'state', s);
      }
    };

    MouselabMDP.prototype.mouseoutState = function(g, s) {
      if (this.stateLabels && this.stateDisplay === 'hover') {
        g.setLabel('');
        return this.recordQuery('mouseout', 'state', s);
      }
    };

    MouselabMDP.prototype.clickEdge = function(g, s0, r, s1) {
      var ref;
      if (!this.complete && g.label.text === '?') {
        LOG_DEBUG("clickEdge " + s0 + " " + r + " " + s1);
        if (this.edgeLabels && this.edgeDisplay === 'click' && ((ref = g.label.text) === '?' || ref === '')) {
          g.setLabel(this.getEdgeLabel(s0, r, s1));
          return this.recordQuery('click', 'edge', s0 + "__" + s1);
        }
      }
    };

    MouselabMDP.prototype.mouseoverEdge = function(g, s0, r, s1) {
      if (this.edgeLabels && this.edgeDisplay === 'hover') {
        g.setLabel(this.getEdgeLabel(s0, r, s1));
        return this.recordQuery('mouseover', 'edge', s0 + "__" + s1);
      }
    };

    MouselabMDP.prototype.mouseoutEdge = function(g, s0, r, s1) {
      if (this.edgeLabels && this.edgeDisplay === 'hover') {
        g.setLabel('');
        return this.recordQuery('mouseout', 'edge', s0 + "__" + s1);
      }
    };

    MouselabMDP.prototype.getEdgeLabel = function(s0, r, s1) {
      if (this.edgeLabels === 'reward') {
        return '®';
      } else {
        return this.edgeLabels[s0 + "__" + s1];
      }
    };

    MouselabMDP.prototype.recordQuery = function(queryType, targetType, target) {
      this.canvas.renderAll();
      this.data.queries[queryType][targetType].target.push(target);
      return this.data.queries[queryType][targetType].time.push(Date.now() - this.initTime);
    };

    MouselabMDP.prototype.arrive = function(s, repeat) {
      var a, g, keys;
      if (repeat == null) {
        repeat = false;
      }
      g = this.states[s];
      console.log('g', g);
      g.setLabel(this.stateRewards[s]);
      this.canvas.renderAll();
      this.freeze = false;
      LOG_DEBUG('arrive', s);
      if (!repeat) {
        this.data.path.push(s);
      }
      if (this.graph[s]) {
        keys = (function() {
          var i, len, ref, results;
          ref = Object.keys(this.graph[s]);
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            a = ref[i];
            results.push(this.keys[a]);
          }
          return results;
        }).call(this);
      } else {
        keys = [];
      }
      if (this.allowSimulation) {
        keys.push('space');
      }
      if (!keys.length) {
        this.complete = true;
        this.checkFinished();
        return;
      }
      return this.keyListener = jsPsych.pluginAPI.getKeyboardResponse({
        valid_responses: keys,
        rt_method: 'date',
        persist: false,
        allow_held_key: false,
        callback_function: (function(_this) {
          return function(info) {
            var action;
            action = _this.invKeys[info.key];
            LOG_DEBUG('key', info.key);
            _this.data.rt.push(info.rt);
            return _this.handleKey(s, action);
          };
        })(this)
      });
    };

    MouselabMDP.prototype.addScore = function(v) {
      var score;
      console.log('addScore', v, SCORE);
      this.data.score += v;
      if (this.simulationMode) {
        score = this.data.score;
      } else {
        SCORE += v;
        score = SCORE;
      }
      return this.drawScore(score);
    };

    MouselabMDP.prototype.resetScore = function() {
      this.data.score = 0;
      return this.drawScore(SCORE);
    };

    MouselabMDP.prototype.drawScore = function(score) {
      $('#mouselab-score').html('$' + score);
      return $('#mouselab-score').css('color', redGreen(score));
    };

    MouselabMDP.prototype.spendEnergy = function(v) {
      this._block.energyLeft -= v;
      if (this._block.energyLeft <= 0) {
        LOG_INFO('OUT OF ENERGY');
        this._block.energyLeft = 0;
        this.freeze = true;
        this.lowerMessage.html("<b>You're out of energy! Press</b> <code>space</code> <b>to continue.</br>");
        this.endBlock();
      }
      return $('#mouselab-energy').html(this._block.energyLeft);
    };

    MouselabMDP.prototype.run = function() {
      jsPsych.pluginAPI.cancelAllKeyboardResponses();
      LOG_DEBUG('run');
      this.buildMap();
      fabric.Image.fromURL(this.playerImage, ((function(_this) {
        return function(img) {
          _this.initPlayer(img);
          _this.canvas.renderAll();
          _this.initTime = Date.now();
          return _this.arrive(_this.initial);
        };
      })(this)));
      if (this.timeLimit) {
        return this.startTimer();
      }
    };

    MouselabMDP.prototype.draw = function(obj) {
      this.canvas.add(obj);
      return obj;
    };

    MouselabMDP.prototype.initPlayer = function(img) {
      var left, top;
      LOG_DEBUG('initPlayer');
      top = this.states[this.initial].top + TOP_ADJUST;
      left = this.states[this.initial].left;
      img.scale(0.25);
      img.set('top', top).set('left', left);
      this.draw(img);
      return this.player = img;
    };

    MouselabMDP.prototype.buildMap = function() {
      var a, actions, height, location, maxx, maxy, minx, miny, r, ref, ref1, ref2, ref3, results, s, s0, s1, width, x, xs, y, ys;
      ref = _.unzip(_.values(this.layout)), xs = ref[0], ys = ref[1];
      minx = _.min(xs);
      miny = _.min(ys);
      maxx = _.max(xs);
      maxy = _.max(ys);
      ref1 = [maxx - minx + 1, maxy - miny + 1], width = ref1[0], height = ref1[1];
      this.canvasElement.attr({
        width: width * SIZE,
        height: height * SIZE
      });
      this.canvas = new fabric.Canvas('mouselab-canvas', {
        selection: false
      });
      this.canvas.defaultCursor = 'pointer';
      this.states = {};
      ref2 = removePrivate(this.layout);
      for (s in ref2) {
        location = ref2[s];
        x = location[0], y = location[1];
        this.states[s] = new State(s, x - minx, y - miny, {
          fill: '#bbb',
          label: this.stateDisplay === 'always' ? this.stateLabels[s] : ''
        });
      }
      ref3 = removePrivate(this.graph);
      results = [];
      for (s0 in ref3) {
        actions = ref3[s0];
        results.push((function() {
          var ref4, results1;
          results1 = [];
          for (a in actions) {
            ref4 = actions[a], r = ref4[0], s1 = ref4[1];
            results1.push(new Edge(this.states[s0], r, this.states[s1], {
              label: this.edgeDisplay === 'always' ? this.getEdgeLabel(s0, r, s1) : ''
            }));
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    MouselabMDP.prototype.endTrial = function() {
      window.clearInterval(this.timerID);
      if (this.blockOver) {
        return;
      }
      this.lowerMessage.html("You made <span class=mouselab-score/> on this round.\n<br>\n<b>Press</b> <code>space</code> <b>to continue.</b>");
      $('.mouselab-score').html('$' + this.data.score);
      $('.mouselab-score').css('color', redGreen(this.data.score));
      $('.mouselab-score').css('font-weight', 'bold');
      return this.keyListener = jsPsych.pluginAPI.getKeyboardResponse({
        valid_responses: ['space'],
        rt_method: 'date',
        persist: false,
        allow_held_key: false,
        callback_function: (function(_this) {
          return function(info) {
            console.log('CLEAR');
            jsPsych.finishTrial(_this.data);
            return _this.stage.empty();
          };
        })(this)
      });
    };

    MouselabMDP.prototype.checkFinished = function() {
      if (this.complete) {
        return this.endTrial();
      }
    };

    return MouselabMDP;

  })();
  State = (function() {
    function State(name, left, top, config) {
      var conf;
      this.name = name;
      if (config == null) {
        config = {};
      }
      left = (left + 0.5) * SIZE;
      top = (top + 0.5) * SIZE;
      conf = {
        left: left,
        top: top,
        fill: '#bbbbbb',
        radius: SIZE / 4,
        label: ''
      };
      _.extend(conf, config);
      this.circle = new fabric.Circle(conf);
      this.label = new Text('----------', left, top, {
        fontSize: SIZE / 4,
        fill: '#44d'
      });
      this.radius = this.circle.radius;
      this.left = this.circle.left;
      this.top = this.circle.top;
      mdp.canvas.add(this.circle);
      mdp.canvas.add(this.label);
      this.circle.on('mousedown', (function(_this) {
        return function() {
          return mdp.clickState(_this, _this.name);
        };
      })(this));
      this.circle.on('mouseover', (function(_this) {
        return function() {
          return mdp.mouseoverState(_this, _this.name);
        };
      })(this));
      this.circle.on('mouseout', (function(_this) {
        return function() {
          return mdp.mouseoutState(_this, _this.name);
        };
      })(this));
      this.setLabel(conf.label);
    }

    State.prototype.setLabel = function(txt, conf) {
      var post, pre, ref, ref1;
      if (conf == null) {
        conf = {};
      }
      LOG_DEBUG('setLabel', txt);
      pre = (ref = conf.pre) != null ? ref : '', post = (ref1 = conf.post) != null ? ref1 : '';
      if (txt != null) {
        this.label.setText("" + pre + txt + post);
        this.label.setFill(redGreen(txt));
      } else {
        this.label.setText('');
      }
      return this.dirty = true;
    };

    return State;

  })();
  Edge = (function() {
    function Edge(c1, reward, c2, config) {
      var adjX, adjY, ang, labX, labY, label, ref, ref1, ref2, ref3, ref4, ref5, ref6, rotateLabel, spacing, x1, x2, y1, y2;
      if (config == null) {
        config = {};
      }
      spacing = (ref = config.spacing) != null ? ref : 8, adjX = (ref1 = config.adjX) != null ? ref1 : 0, adjY = (ref2 = config.adjY) != null ? ref2 : 0, rotateLabel = (ref3 = config.rotateLabel) != null ? ref3 : false, label = (ref4 = config.label) != null ? ref4 : '';
      ref5 = [c1.left + adjX, c1.top + adjY, c2.left + adjX, c2.top + adjY], x1 = ref5[0], y1 = ref5[1], x2 = ref5[2], y2 = ref5[3];
      this.arrow = new Arrow(x1, y1, x2, y2, c1.radius + spacing, c2.radius + spacing);
      ang = (this.arrow.ang + Math.PI / 2) % (Math.PI * 2);
      if ((0.5 * Math.PI <= ang && ang <= 1.5 * Math.PI)) {
        ang += Math.PI;
      }
      ref6 = polarMove(x1, y1, angle(x1, y1, x2, y2), SIZE * 0.45), labX = ref6[0], labY = ref6[1];
      this.label = new Text('----------', labX, labY, {
        angle: rotateLabel ? ang * 180 / Math.PI : 0,
        fill: redGreen(label),
        fontSize: SIZE / 4,
        textBackgroundColor: 'white'
      });
      this.arrow.on('mousedown', (function(_this) {
        return function() {
          return mdp.clickEdge(_this, c1.name, reward, c2.name);
        };
      })(this));
      this.arrow.on('mouseover', (function(_this) {
        return function() {
          return mdp.mouseoverEdge(_this, c1.name, reward, c2.name);
        };
      })(this));
      this.arrow.on('mouseout', (function(_this) {
        return function() {
          return mdp.mouseoutEdge(_this, c1.name, reward, c2.name);
        };
      })(this));
      this.setLabel(label);
      mdp.canvas.add(this.arrow);
      mdp.canvas.add(this.label);
    }

    Edge.prototype.setLabel = function(txt, conf) {
      var post, pre, ref, ref1;
      if (conf == null) {
        conf = {};
      }
      pre = (ref = conf.pre) != null ? ref : '', post = (ref1 = conf.post) != null ? ref1 : '';
      if (txt) {
        this.label.setText("" + pre + txt + post);
        this.label.setFill(redGreen(txt));
      } else {
        this.label.setText('');
      }
      return this.dirty = true;
    };

    return Edge;

  })();
  Arrow = (function(superClass) {
    extend(Arrow, superClass);

    function Arrow(x1, y1, x2, y2, adj1, adj2) {
      var ang, centerX, centerY, deltaX, deltaY, dx, dy, line, point, ref, ref1;
      if (adj1 == null) {
        adj1 = 0;
      }
      if (adj2 == null) {
        adj2 = 0;
      }
      ang = angle(x1, y1, x2, y2);
      ref = polarMove(x1, y1, ang, adj1), x1 = ref[0], y1 = ref[1];
      ref1 = polarMove(x2, y2, ang, -(adj2 + 7.5)), x2 = ref1[0], y2 = ref1[1];
      line = new fabric.Line([x1, y1, x2, y2], {
        stroke: '#555',
        selectable: false,
        strokeWidth: 3
      });
      centerX = (x1 + x2) / 2;
      centerY = (y1 + y2) / 2;
      deltaX = line.left - centerX;
      deltaY = line.top - centerY;
      dx = x2 - x1;
      dy = y2 - y1;
      point = new fabric.Triangle({
        left: x2 + deltaX,
        top: y2 + deltaY,
        pointType: 'arrow_start',
        angle: ang * 180 / Math.PI,
        width: 10,
        height: 10,
        fill: '#555'
      });
      Arrow.__super__.constructor.call(this, [line, point]);
      this.ang = ang;
      this.centerX = centerX;
      this.centerY = centerY;
    }

    return Arrow;

  })(fabric.Group);
  Text = (function(superClass) {
    extend(Text, superClass);

    function Text(txt, left, top, config) {
      var conf;
      txt = String(txt);
      conf = {
        left: left,
        top: top,
        fontFamily: 'helvetica',
        fontSize: SIZE / 8
      };
      _.extend(conf, config);
      Text.__super__.constructor.call(this, txt, conf);
    }

    return Text;

  })(fabric.Text);
  plugin = {
    trial: function(display_element, trialConfig) {
      var trial;
      trialConfig.display = display_element;
      LOG_INFO('trialConfig', trialConfig);
      trial = new MouselabMDP(trialConfig);
      trial.run();
      if (trialConfig._block) {
        trialConfig._block.trialCount += 1;
      }
      return TRIAL_INDEX += 1;
    }
  };
  return plugin;
})();
